using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.ChatCompletion;

public class HtmlImageParser
{
    public record ParseResult(string CleanedHtml, List<ParsedImage> Images);

    public record ParsedImage(string Placeholder, ImageContent Content);

    private static readonly HttpClient _httpClient = new HttpClient();

    /// <summary>
    /// Parse HTML and return cleaned HTML (placeholders) and list of parsed images (placeholder + ImageContent).
    /// Supports data: (base64) images, absolute URLs, and local file paths (resolved against baseDirectory).
    /// </summary>
    public static async Task<ParseResult> ParseAsync(string html, string baseDirectory = "")
    {
        if (string.IsNullOrWhiteSpace(html))
            return new ParseResult(html ?? string.Empty, new List<ParsedImage>());

        var images = new List<ParsedImage>();
        int counter = 0;

        string pattern = @"<img[^>]+src=[""']([^""']+)[""'][^>]*>";
        var matches = Regex.Matches(html, pattern, RegexOptions.IgnoreCase | RegexOptions.Singleline);

        // We'll build cleanedHtml by walking through matches to preserve non-matched text.
        var sb = new StringBuilder();
        int lastIndex = 0;

        foreach (Match match in matches)
        {
            // Append text before match
            sb.Append(html[lastIndex..match.Index]);

            counter++;
            string src = match.Groups[1].Value;
            string placeholder = $"[Image_{counter}]";

            // Default: no image content yet
            ImageContent? imgContent = null;

            try
            {
                if (src.StartsWith("data:image/", StringComparison.OrdinalIgnoreCase))
                {
                    // Already base64 data URI — pass it as DataUri
                    imgContent = new ImageContent
                    {
                        DataUri = src
                    };
                }
                else if (Uri.IsWellFormedUriString(src, UriKind.Absolute))
                {
                    // Download remote image and convert to data URI
                    var bytes = await _httpClient.GetByteArrayAsync(src);
                    string mime = GetMimeTypeFromUrl(src) ?? "image/png";
                    string base64 = Convert.ToBase64String(bytes);
                    string dataUri = $"data:{mime};base64,{base64}";
                    imgContent = new ImageContent { DataUri = dataUri };
                }
                else
                {
                    // Treat as local path (relative or absolute)
                    string fullPath = Path.IsPathRooted(src) ? src : Path.Combine(baseDirectory ?? string.Empty, src);

                    if (File.Exists(fullPath))
                    {
                        // Use the file path constructor so SK can read it as a file
                        imgContent = new ImageContent(fullPath);
                    }
                    else
                    {
                        // If file missing, fallback to a small text ImageContent won't work — skip and log
                        Console.WriteLine($"⚠️ Missing local image file: {fullPath}");
                    }
                }

                if (imgContent != null)
                {
                    images.Add(new ParsedImage(placeholder, imgContent));
                }
            }
            catch (Exception ex)
            {
                // Log and continue (don't break whole parse for one bad image)
                Console.WriteLine($"❌ Failed to process image '{src}': {ex.Message}");
            }

            // Replace the <img> tag with placeholder
            sb.Append(placeholder);

            lastIndex = match.Index + match.Length;
        }

        // Append remaining tail of the HTML
        sb.Append(html[lastIndex..]);

        return new ParseResult(sb.ToString(), images);
    }

    private static string? GetMimeTypeFromUrl(string url)
    {
        try
        {
            var ext = Path.GetExtension(new Uri(url).AbsolutePath).ToLowerInvariant();
            return ext switch
            {
                ".png" => "image/png",
                ".jpg" or ".jpeg" => "image/jpeg",
                ".gif" => "image/gif",
                ".webp" => "image/webp",
                ".bmp" => "image/bmp",
                _ => null
            };
        }
        catch
        {
            return null;
        }
    }
}





string html = File.ReadAllText("report.html");

var result = await HtmlImageParser.ParseAsync(html, baseDirectory: Path.GetDirectoryName("report.html"));

// Cleaned text (with placeholders)
Console.WriteLine(result.CleanedHtml);

// Image list
foreach (var img in result.Images)
{
    Console.WriteLine($"{img.Description} => {(img.DataUri != null ? "Inline/Base64" : img.FilePath)}");
}







using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;

var kernel = Kernel.CreateBuilder()
    .AddOpenAIChatCompletion("gpt-4o", "your-api-key")
    .Build();

var chat = kernel.GetRequiredService<IChatCompletion>();

var message = new ChatMessageContent(
    AuthorRole.User,
    "Analyze the following HTML document and corresponding images. " +
    "Each [Image_x] placeholder refers to the corresponding image."
);

message.Contents.Add(new TextContent(result.CleanedHtml));

foreach (var img in result.Images)
{
    message.Contents.Add(img);
}

var response = await chat.GetChatMessageContentAsync(message);
Console.WriteLine(response.Content);






string html = File.ReadAllText("report.html");

var result = await HtmlImageParser.ParseAsync(html, baseDirectory: Path.GetDirectoryName("report.html"));

// Cleaned text (with placeholders)
Console.WriteLine(result.CleanedHtml);

// Image list
foreach (var img in result.Images)
{
    Console.WriteLine($"{img.Description} => {(img.DataUri != null ? "Inline/Base64" : img.FilePath)}");
}







using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Microsoft.SemanticKernel.ChatCompletion;

var kernel = Kernel.CreateBuilder()
    .AddOpenAIChatCompletion("gpt-4o", "your-api-key")
    .Build();

var chat = kernel.GetRequiredService<IChatCompletion>();

var message = new ChatMessageContent(
    AuthorRole.User,
    "Analyze the following HTML document and corresponding images. " +
    "Each [Image_x] placeholder refers to the corresponding image."
);

message.Contents.Add(new TextContent(result.CleanedHtml));

foreach (var img in result.Images)
{
    message.Contents.Add(img);
}

var response = await chat.GetChatMessageContentAsync(message);
Console.WriteLine(response.Content);


